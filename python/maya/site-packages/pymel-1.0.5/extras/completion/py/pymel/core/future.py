from . import context
from . import rendering
import maya.cmds as cmds
import pymel.util as util
from . import runtime
import pymel.api as api
from . import system
from . import uitypes as ui
from . import uitypes
from . import nodetypes
from . import nodetypes as nt
from . import animation
from . import datatypes as dt
from . import language
import pymel.util.nameparse as nameparse
import pymel.internal.factories as _factories
from . import windows
from . import modeling
from . import effects

from pymel.core.general import *
from pymel.core.system import *
from pymel.core.windows import *
from pymel.core.animation import *
from pymel.core.context import *
from pymel.core.modeling import *
from pymel.core.other import *
from pymel.core.rendering import *
from pymel.core.effects import *

from pymel.core.language import Env
from pymel.core.language import callbacks
from pymel.core.language import MelConversionError
from pymel.core.language import MelError
from pymel.core.language import Mel
from pymel.core.language import evalNoSelectNotify
from pymel.core.language import Catch
from pymel.core.language import getProcArguments
from pymel.core.language import pythonToMel
from pymel.core.language import stackTrace
from pymel.core.language import resourceManager
from pymel.core.language import isValidMelType
from pymel.core.language import getMelType
from pymel.core.language import conditionExists
from pymel.core.language import OptionVarList
from pymel.core.language import MelUnknownProcedureError
from pymel.core.language import getLastError
from pymel.core.language import MelArgumentError
from pymel.core.language import evalEcho
from pymel.core.language import getMelGlobal
from pymel.core.language import OptionVarDict
from pymel.core.language import MelGlobals
from pymel.core.language import scriptJob
from pymel.core.language import python
from pymel.core.language import pythonToMelCmd
from pymel.core.language import MelSyntaxError
from pymel.core.language import setMelGlobal
from pymel.core.language import waitCursor

def iterNodes(*args, **kwargs):
    """
    Iterates on nodes of the argument list, or when args is empty on nodes of the Maya scene,
    that meet the given conditions.
    
    WARNING: This function is still a work in progress.
    
    The following keywords change the way the iteration is done :
    
    :Keywords:
        selection : bool : False
            will use current selection if no nodes are passed in the arguments list,
            or will filter argument list to keep only selected nodes
        above : int : 0
            for each returned dag node will also iterate on its n first ancestors
        below : int : 0
            for each returned dag node will also iterate on levels of its descendents
        parents : bool : False
            if True is equivalent to above = 1
        childs : bool : False
            if True is equivalent to below = 1
        asList : bool : False
        asTree : bool : False
        breadth : bool : False
        underworld : bool : False
        allPaths : bool : False
        prune : bool : False
    
    
    The following keywords specify conditions the iterated nodes are filtered against, conditions can be passed either as a
    list of conditions, format depending on condition type, or a dictionnary of {condition:result} with result True or False
    
    :Keywords:
        name : string or regular expression : None
            will filter nodes that match these names. Names can be full node names, use wildcards * and ?, or regular expression syntax.
        position = None: will filter dag nodes that have a specific position in their hierarchy :
            'root' for root nodes
            'leaf' for leaves
            'level=<int>' or 'level=[<int>:<int>]' for a specific distance from their root
        type = None: will filter nodes that are of the specified type, or a derived type.
            The types can be specified as Pymel Node types (DependNode and derived) or Maya types names
        property = None: check for specific preset properties, for compatibility with the 'ls' command :
            'visible' : object is visible (it's visibility is True and none of it's ancestor has visibility to False)
            'ghost': ghosting is on for that object
            'templated': object is templated or one of its ancestors is
            'intermediate' : object is marked as "intermediate object"
        attribute = None: each condition is a string made of at least an attribute name and possibly a comparison operator an a value
            checks a specific attribute of the node for existence: '.visibility',
            or against a value: 'translateX >= 2.0'
        user = None: each condition must be a previously defined function taking the iterated object as argument and returning True or False
    
    expression = None: allows to pass the string of a Python expression that will be evaluated on each iterated node,
        and will limit the result to nodes for which the expression evaluates to 'True'. Use the variable 'node' in the
        expression to represent the currently evaluated node
    
    Conditions of the same type (same keyword) are combined as with a logical 'or' for positive conditions :
    iterNodes(type = ['skinCluster', 'blendShape']) will iter on all nodes of type skinCluster OR blendShape
    Conditions of the type (same keyword) are combined as with a logical 'and' for negative conditions :
    iterNodes(type = ['!transform', '!blendShape']) will iter on all nodes of type not transform AND not blendShape
    Different conditions types (different keyword) are combined as with a logical 'and' :
    iterNodes(type = 'skinCluster', name = 'bodySkin*') will iter on all nodes that have type skinCluster AND whose name
    starts with 'bodySkin'.
    
    Examples : (TODO)
    """

    pass


def _activeSelection():
    pass


def iterConnections(*args, **kwargs):
    pass


def _addCondition(cDic, key, val):
    pass


def iterHierarchy(*args, **kwargs):
    pass


def _apiSelectionToList(sel):
    """
    # Selection list to PyNodes
    """

    pass


def _optToDict(*args, **kwargs):
    pass



MELTYPES = []

optionVar = {}

catch = None

env = None


